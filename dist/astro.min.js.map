{
  "version": 3,
  "sources": ["../src/Math.js", "../src/Orbit.js"],
  "sourcesContent": ["/*############################################################################*/\r\n// AstroJS Base Math Module (c) 2016 by Marcel Greter\r\n// https://www.github.com/mgreter/astrojs/LICENSE\r\n/*############################################################################*/\r\n\r\n\r\nimport * as THREE from 'three'\r\n\r\n\r\n// global constants for math operations\r\n\r\n// use TAU, PI is wrong ;)\r\nexport const PI = 1 * Math.PI;\r\nexport const TAU = 2 * Math.PI;\r\n\r\n// create namespace for constants\r\n// we still define local variables\r\n// wrap anonymous function around!\r\n//var AstroJS = this.AstroJS = {\r\n\r\n// astronomical units to meters\r\nexport const AU2M = 1.495978707e+11\r\n// astronomical units to kilometers\r\nexport const AU2KM = 1.495978707e+8\r\n// parsecs to meters\r\nexport const PC2M = 30856776e9\r\n// parsecs to AUs\r\nexport const PC2AU = 206265\r\nexport const PC2LY = 3.26156\r\n// metric conversion\r\nexport const KM2M = 1000\r\n// julian day conversion\r\n// JDs in one JY\r\nexport const JY2JD = 365.25\r\n// time conversion\r\nexport const JD2SEC = 24 * 60 * 60\r\n// solar mass conversion\r\nexport const MSOL2KG = 1.98855e30\r\n// trig conversion factors\r\nexport const DEG2RAD = TAU / 360\r\n// not very useful!\r\n// HMS2RAD: TAU / 24,\r\n// HMS2DEG: 360 / 24,\r\n//}\r\n\r\n// JulianYear    = 365.25      // days\r\n// JulianCentury = 36525       // days\r\n// BesselianYear = 365.2421988 // days\r\n\r\n// TODO(pablo): fix\r\n// create inverted functions\r\n// for (var name in AstroJS) {\r\n//   const units = name.split('2', 2);\r\n//  const inv = units.reverse().join('2');\r\n//  AstroJS[inv] = 1 / AstroJS[name];\r\n// }\r\n\r\n\r\n// degrees, minutes, seconds to rad\r\nexport function DMS2RAD(d, m, s) {\r\n  let dms = Math.abs(d)\r\n  const sigma = d < 0 ? -1 : 1\r\n  dms += m / 60 + s / 60 / 60\r\n  return sigma * dms * DEG2RAD\r\n}\r\n\r\n// hours, minutes, seconds to rad\r\nexport function HMS2RAD(h, m, s) {\r\n  return DMS2RAD(h, m, s) * 15\r\n}\r\n\r\n// J2000 epoch in JD\r\nexport const JD2000 = 2451545.0\r\n\r\n// Gravitational parameters for astronomic scale\r\n// time in days, distance in AU, mass in sun-mass\r\n// http://astronomy.stackexchange.com/a/7981\r\n// GM * M2AU^3 * JD2SEC^2 * MSOL2KG\r\nexport const GMJD = {\r\n  // VSOP2013 Masses system (INPOP10A)\r\n  sun: 2.9591220836841438269e-04, // sun\r\n  mer: 4.9125474514508118699e-11, // mer\r\n  ven: 7.2434524861627027000e-10, // ven\r\n  ear: 8.9970116036316091182e-10, // ear\r\n  emb: 8.9970116036316091182e-10, // emb\r\n  mar: 9.5495351057792580598e-11, // mar\r\n  jup: 2.8253458420837780000e-07, // jup\r\n  sat: 8.4597151856806587398e-08, // sat\r\n  ura: 1.2920249167819693900e-08, // ura\r\n  nep: 1.5243589007842762800e-08, // nep\r\n  plu: 2.1886997654259696800e-12, // plu\r\n  moon: 1.0936508975881017456e-11 // moon\r\n}\r\n\r\n// covert to a different time factor\r\n// time in julian years, distance in AU\r\nexport const GMJY = {}\r\nfor (const name in GMJD) {\r\n  GMJY[name] = GMJD[name]\r\n  GMJY[name] *= 133407.5625\r\n  // => Math.pow(365.25, 2)\r\n}\r\n\r\n// covert to a different time factor\r\n// time in julian seconds, distance in AU\r\n// https://www.aanda.org/articles/aa/full_html/2013/09/aa21843-13/T1.html\r\nexport const GMJS = {}\r\nfor (const name in GMJD) {\r\n  GMJS[name] = GMJD[name]\r\n  GMJS[name] /= 746496e4\r\n  // => Math.pow(86400, 2)\r\n}\r\n\r\n\r\n\r\n/** from 0 to TAU, one full cycle */\r\nexport function CYCLE(rad) {\r\n  rad %= TAU\r\n  if (rad < 0) {\r\n    rad += TAU\r\n  }\r\n  return rad\r\n}\r\n\r\n\r\n/** from -PI to +PI, turn left/right */\r\nexport function TURN(rad) {\r\n  rad %= TAU\r\n  if (rad > PI) {\r\n    rad -= TAU\r\n  }\r\n  return rad\r\n}\r\n\r\n\r\n// Julian Days to J2000\r\nexport function JDtoJY2K(JD) {\r\n  // offset epoch and add ratio\r\n  return (JD - JD2000) / JY2JD\r\n}\r\n\r\n\r\n// J2000 to Julian Days\r\nexport function JY2KtoJD(J2K) {\r\n  // add ratio and offset epoch\r\n  return J2K * JY2JD + JD2000\r\n}\r\n\r\n// internal constants for math operations\r\n\r\n// maximum iterations to find\r\n// a value in range for epsilon\r\n// used in Newton-Raphson solver\r\nexport const MAXLOOP = 12\r\n\r\n// polyfill for cube root function\r\n// from https://developer.mozilla.org\r\nMath.cbrt = Math.cbrt || function (x) {\r\n  const y = Math.pow(Math.abs(x), 1 / 3)\r\n  return x < 0 ? -y : y\r\n}\r\n\r\n// makes it easier to port C code\r\nMath.fmod = Math.fmod || function (a, b) {\r\n  return a % b\r\n}\r\n", "/*############################################################################*/\r\n// AstroJS Orbit Module (c) 2016 by Marcel Greter\r\n// https://www.github.com/mgreter/astrojs/LICENSE\r\n/*############################################################################*/\r\n// http://www.lns.cornell.edu/~seb/celestia/orbital-parameters.html\r\n// Similar module: https://github.com/jordanstephens/kepler.js\r\n/*############################################################################*/\r\n'use strict';\r\n\r\n\r\n// TODO(pablo): review with Marcel\r\n// import * as Three from '../lib/three.math.js'\r\nimport * as Math from './Math.js'\r\n\r\n\r\n(function (exports)\r\n{\r\n\r\n\t// Alias for math functions\r\n\t// Better compressibility\r\n\t// Saves about 0.4kb\r\n\tvar abs = Math.abs;\r\n\tvar pow = Math.pow;\r\n\tvar sin = Math.sin;\r\n\tvar cos = Math.cos;\r\n\tvar sqrt = Math.sqrt;\r\n\tvar cbrt = Math.cbrt;\r\n\tvar atan2 = Math.atan2;\r\n\r\n\t// Ensure valid range\r\n\tfunction asin(angle) {\r\n\t\treturn Math.asin(Math.min(1,\r\n\t\t\tMath.max(-1, angle)));\r\n\t}\r\n\r\n\t// Ensure valid range\r\n\tfunction acos(angle) {\r\n\t\treturn Math.acos(Math.min(1,\r\n\t\t\tMath.max(-1, angle)));\r\n\t}\r\n\r\n\t/******************************************************************************/\r\n\t// Orbits can be created from orbital elements (6 independent parameters)\r\n\t// or from state vectors (position and velocity). In both cases we need 6\r\n\t// arguments to fully define an orbit. Most related parameters will be\r\n\t// calculated on construction. But certain parameters as the true anomaly\r\n\t// are a bit more complex to calculate from orbital elements, if only the\r\n\t// mean anomaly is given as initial parameters. They are lazy calculated\r\n\t// on demand, either by using the getter or invoking updateElements(true).\r\n\t/******************************************************************************/\r\n\t// To get state vectors for different times we just add a linear factor\r\n\t// to the mean anomaly (related to mean motion and period). To get the\r\n\t// actual state vectors from the mean anomaly we need to compute the\r\n\t// solution for Kepler's Equation via Newton-Raphson solver loop.\r\n\t/******************************************************************************/\r\n\t// Keep in mind that all angular parameters are in rads and that all\r\n\t// other units are linked to each other. This means that you can change\r\n\t// the units by adjusting the gravitational parameter. We use the solar\r\n\t// gravitational parameter by default with the units: au^3/(solm*day^2).\r\n\t// Normally in physics this parameter is measured in m^3/(kg*s^2). All\r\n\t// distance and time units must therefore be in the same units as `GM`.\r\n\t/******************************************************************************/\r\n\t// ToDo: finish and add tests for circular and hyperbola orbits.\r\n\t/******************************************************************************/\r\n\r\n\tfunction Orbit(arg)\r\n\t{\r\n\r\n\t\tvar orbit = this;\r\n\r\n\t\t// internal use\r\n\t\tif (arg.empty) {\r\n\t\t\treturn orbit;\r\n\t\t}\r\n\r\n\t\t// Give a warning about passing renamed parameter G\r\n\t\tif ('G' in arg) console.warn('G has been renamed to GM');\r\n\r\n\t\t// the gravitational parameter is very important and must\r\n\t\t// match all others in terms of the units. In physics the\r\n\t\t// units are by default m^3/(kg*s^2), but for astronomical\r\n\t\t// uses we most often want to use au^3/(solm*day^2).\r\n\t\torbit._GM = arg.GM || arg.G || Orbit.GMP.sun,\r\n\t\t\torbit._t = arg.epoch || arg.t || 0;\r\n\t\torbit.translate = arg.translate || null;\r\n\r\n\t\t// create state vectors from input parameters\r\n\t\tif ('x' in arg && 'y' in arg && 'z' in arg) {\r\n\t\t\torbit._r = new Vector3(arg.x, arg.y, arg.z);\r\n\t\t}\r\n\t\telse if ('rx' in arg && 'ry' in arg && 'rz' in arg) {\r\n\t\t\torbit._r = new Vector3(arg.rx, arg.ry, arg.rz);\r\n\t\t}\r\n\t\tif ('X' in arg && 'Y' in arg && 'Z' in arg) {\r\n\t\t\torbit._v = new Vector3(arg.X, arg.Y, arg.Z);\r\n\t\t}\r\n\t\telse if ('vx' in arg && 'vy' in arg && 'vz' in arg) {\r\n\t\t\torbit._v = new Vector3(arg.vx, arg.vy, arg.vz);\r\n\t\t}\r\n\r\n\t\tif ('r' in arg && 'v' in arg) {\r\n\t\t\tvar r = arg.r, v = arg.v;\r\n\t\t\t// create new vectors (want a clone anyway)\r\n\t\t\torbit._r = new Vector3(r.x, r.y, r.z);\r\n\t\t\torbit._v = new Vector3(v.x, v.y, v.z);\r\n\t\t}\r\n\r\n\t\t// set status for state vectors\r\n\t\torbit.vectors = !!(orbit._r && orbit._v);\r\n\r\n\t\t// get other parameters from arg\r\n\t\t// unknown parameters are ignored\r\n\t\tvar vars = 'aeiMnPLcCwWOkhqpG'.split('');\r\n\t\tfor (var i in vars) {\r\n\t\t\tif (arg.hasOwnProperty(vars[i])) {\r\n\t\t\t\torbit['_' + vars[i]] = arg[vars[i]];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// precession periods\r\n\t\torbit._PW = arg.PW || 0;\r\n\t\torbit._PO = arg.PO || 0;\r\n\r\n\t\t// orbit may has name\r\n\t\tif ('name' in arg) {\r\n\t\t\torbit.name = arg.name;\r\n\t\t}\r\n\r\n\t\t// resolve if not lazy\r\n\t\tif (!orbit.lazy) {\r\n\t\t\torbit.updateElements();\r\n\t\t\torbit.requireElements();\r\n\t\t}\r\n\r\n\t}\r\n\t// EO Orbit ctor\r\n\r\n\t// use mass system\r\n\t// has julian days\r\n\tOrbit.GMP = Math.GMJD;\r\n\r\n\t// optimized for minifier\r\n\tvar Klass = Orbit.prototype;\r\n\r\n\t/******************************************************************************/\r\n\t// clone the existing orbital\r\n\t/******************************************************************************/\r\n\r\n\t// copy existing orbit and return clone\r\n\tKlass.clone = function clone(jy2k)\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\tvar epoch = orbit._t || 0;\r\n\t\tvar dt = jy2k == null ?\r\n\t\t\t0 :  jy2k - epoch;\r\n\t\t// create an empty object (internal use)\r\n\t\tvar clone = new Orbit({ empty: true });\r\n\t\t// avoid unnecessary cloning of objects\r\n\t\tif (dt) { delete orbit._v; delete orbit._r; }\r\n\t\t// process all properties\r\n\t\tfor (var key in orbit) {\r\n\t\t\tif (orbit.hasOwnProperty(key)) {\r\n\t\t\t\t// invoke nested clone functions (vectors)\r\n\t\t\t\tif (orbit[key] && typeof orbit[key].clone == 'function')\r\n\t\t\t\t{ clone[key] = orbit[key].clone(); }\r\n\t\t\t\telse { clone[key] = orbit[key]; }\r\n\t\t\t}\r\n\t\t}\r\n\t\t// optionally call update\r\n\t\tif (dt) clone._update(jy2k);\r\n\t\t// return copy\r\n\t\treturn clone;\r\n\t}\r\n\r\n\t/******************************************************************************/\r\n\t// check current object for valid resolved state\r\n\t/******************************************************************************/\r\n\tKlass.checkElements = function checkElements(full)\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\t// most basic check for initial pre-calculations\r\n\t\tif (!orbit.elements) throw ('Orbitals not calculated');\r\n\t\t// do some basic checks for needed orbital elements\r\n\t\tif (!('_i' in orbit)) throw ('Orbit is missing inclination (i)');\r\n\t\tif (!('_e' in orbit)) throw ('Orbit is missing eccentricity (e)');\r\n\t\tif (!('_a' in orbit)) throw ('Orbit is missing semi-major axis (a)');\r\n\t\tif (!('_b' in orbit)) throw ('Orbit is missing semi-minor axis (b)');\r\n\t\tif (!('_l' in orbit)) throw ('Orbit is missing semi-latus rectum (l)');\r\n\t\tif (!('_c' in orbit)) throw ('Orbit is missing periapsis (c)');\r\n\t\tif (!('_C' in orbit)) throw ('Orbit is missing apoapsis (C)');\r\n\t\tif (!('_L' in orbit)) throw ('Orbit is missing mean longitude (L)');\r\n\t\tif (!('_O' in orbit)) throw ('Orbit is missing right ascending node (O)');\r\n\t\tif (!('_T' in orbit)) throw ('Orbit is missing time of periapsis (w)');\r\n\t\tif (!('_t' in orbit)) throw ('Orbit is missing time of reference epoch (t)');\r\n\t\tif (!('_w' in orbit)) throw ('Orbit is missing argument of periapsis (w)');\r\n\t\tif (!('_W' in orbit)) throw ('Orbit is missing longitude of the periapsis (W)');\r\n\t\tif (!('_n' in orbit)) throw ('Orbit is missing mean motion (n)');\r\n\t\tif (!('_M' in orbit)) throw ('Orbit is missing mean anomaly (M)');\r\n\t\tif (!('_P' in orbit)) throw ('Orbit is missing orbital period (P)');\r\n\t\tif (!('_A' in orbit)) throw ('Orbit is missing angular momentum (A)');\r\n\t\tif (!('_c' in orbit)) throw ('Orbit is missing pericenter (c)');\r\n\t\tif (!('_C' in orbit)) throw ('Orbit is missing apocenter (C)');\r\n\t\t// check if eccentricity is inside valid boundaries (0-1)\r\n\t\tif (orbit._e < 0) throw ('Negative eccentricity is invalid');\r\n\t\tif (orbit._e > 1) throw ('Eccentricity must not be hyperbolic (> 1)');\r\n\t\tif (orbit._e == 1) throw ('Eccentricity must not be parabolic (== 1)');\r\n\t\t// state vectors (r and v) are not tested here ...\r\n\t\tif (full) if (!('_m' in orbit)) throw ('Orbit is missing true anomaly (m)');\r\n\t\tif (full) if (!('_B' in orbit)) throw ('Orbit is missing radial velocity (B)');\r\n\t\tif (full) if (!('_E' in orbit)) throw ('Orbit is missing eccentric anomaly (E)');\r\n\t}\r\n\r\n\t/******************************************************************************/\r\n\t// ensure certain orbital elements exist: aeiWLMOw\r\n\t/******************************************************************************/\r\n\tKlass.requireElements = function requireElements(full)\r\n\t{\r\n\t\t// invoke resolver (fully)\r\n\t\tthis.updateElements(full);\r\n\t\tthis.checkElements(full);\r\n\t\t// chain-able\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/******************************************************************************/\r\n\t// resolve orbital elements as far as possible\r\n\t/******************************************************************************/\r\n\tKlass.updateElements = function updateElements(full)\r\n\t{\r\n\r\n\t\tvar orbit = this;\r\n\t\t// only resolve elements once\r\n\t\tif (orbit.elements) return orbit;\r\n\t\t// will calculate now\r\n\t\torbit.elements = true;\r\n\r\n\t\t/********************************************************/\r\n\t\t// resolve from state vectors (r, v)\r\n\t\t/********************************************************/\r\n\r\n\t\t// check main state vectors\r\n\t\tif ('_r' in orbit && '_v' in orbit) {\r\n\r\n\t\t\tvar r = orbit._r, v = orbit._v,\r\n\t\t\t\tGM = orbit._GM, rl = r.length();\r\n\r\n\t\t\t// specific relative angular momentum\r\n\t\t\torbit._A3 = r.clone().cross(v);\r\n\t\t\torbit._A2 = orbit._A3.lengthSq();\r\n\t\t\torbit._A = sqrt(orbit._A2);\r\n\t\t\t// calculate radial velocity\r\n\t\t\torbit._B = r.dot(v) / rl;\r\n\r\n\t\t\t// calculate eccentricity vector\r\n\t\t\tvar e3 = orbit._e3 = r.clone().multiplyScalar(v.lengthSq() - (GM / rl))\r\n\t\t\t\t.sub(v.clone().multiplyScalar(rl * orbit._B)).multiplyScalar(1 / GM);\r\n\t\t\t// get eccentricity value from vector\r\n\t\t\tvar e2 = e3.lengthSq(), e = orbit._e = sqrt(e2);\r\n\t\t\t// get inclination (i) via orbital momentum vector\r\n\t\t\torbit._i = acos(orbit._A3.z / orbit._A);\r\n\r\n\t\t\t// calculate semilatus rectum (\u2113)\r\n\t\t\torbit._l = orbit._A2 / GM;\r\n\t\t\t// and periapsis (c) and apoapsis (C)\r\n\t\t\torbit._c = orbit._l / (1 + e);\r\n\t\t\torbit._C = orbit._l / (1 - e);\r\n\t\t\t// and finally semi-major axis (a)\r\n\t\t\torbit._a = (orbit._C + orbit._c) / 2;\r\n\r\n\t\t\t// pre-calculate node line\r\n\t\t\tvar nx = - orbit._A3.y,\r\n\t\t\t\tny = + orbit._A3.x;\r\n\t\t\tvar nl = sqrt(nx * nx + ny * ny);\r\n\r\n\t\t\t// calculate ascending node (O)\r\n\t\t\tvar omega = nl == 0 ? 0 : acos(nx / nl);\r\n\t\t\torbit._O = ny < 0 ? (TAU - omega) : omega;\r\n\r\n\t\t\t// calculate argument of periapsis (\u03C9)\r\n\t\t\tvar nedot = nx * e3.x +\r\n\t\t\t\tny * e3.y;\r\n\t\t\tif (nl === 0 || e === 0) { orbit._w = 0; }\r\n\t\t\telse { orbit._w = acos(nedot / nl / e); }\r\n\t\t\tif (e3.z < 0) { orbit._w *= -1; }\r\n\r\n\t\t\t// calculate true anomaly\r\n\t\t\tvar u; // argument of latitude\r\n\t\t\t// case for circular orbit\r\n\t\t\t// and without inclination\r\n\t\t\tif (e === 0 && nl === 0) {\r\n\t\t\t\t// orbit needs a test case\r\n\t\t\t\tu = acos(r.x / rl);\r\n\t\t\t}\r\n\t\t\t// circular orbit\r\n\t\t\t// with inclination\r\n\t\t\telse if (e === 0) {\r\n\t\t\t\t// orbit needs a test case\r\n\t\t\t\tvar nrdot = nx * r.x + ny * r.y;\r\n\t\t\t\tu = acos(nrdot / (nl * rl));\r\n\t\t\t}\r\n\t\t\t// elliptic orbit\r\n\t\t\telse {\r\n\t\t\t\tvar redot = e3.x * r.x + e3.y * r.y + e3.z * r.z;\r\n\t\t\t\tu = acos(redot / e / rl);\r\n\t\t\t}\r\n\t\t\t// bring into correct range via simple check\r\n\t\t\tvar m = orbit._m = orbit._B < 0 ? (TAU - u) : u;\r\n\r\n\t\t\t// for elliptic orbits\r\n\t\t\tif (e < 1) {\r\n\t\t\t\t// calculate eccentric anomaly\r\n\t\t\t\tvar E = orbit._E = CYCLE(atan2(\r\n\t\t\t\t\tsqrt(1 - e * e) * sin(m),\r\n\t\t\t\t\te + cos(m)\r\n\t\t\t\t));\r\n\t\t\t\t// calculate mean anomaly\r\n\t\t\t\torbit._M = E - e * sin(E);\r\n\t\t\t}\r\n\t\t\t// for hyperbolic orbits\r\n\t\t\telse if (e > 1) {\r\n\t\t\t\t// calculate eccentric anomaly\r\n\t\t\t\tvar E = orbit._E = CYCLE(atan2(\r\n\t\t\t\t\tsqrt(1 - e * e) * sin(m),\r\n\t\t\t\t\te + cos(m)\r\n\t\t\t\t));\r\n\t\t\t\t// calculate mean anomaly\r\n\t\t\t\torbit._M = E - e * sin(E);\r\n\t\t\t}\r\n\r\n\t\t\t// calculate mean anomaly\r\n\t\t\torbit._M = E - e * sin(E);\r\n\r\n\t\t}\r\n\t\t// EO state vectors\r\n\r\n\t\t/********************************************************/\r\n\t\t// VSOP87 uses some exotic orbital elements\r\n\t\t// not sure if they have a technical name\r\n\t\t/********************************************************/\r\n\r\n\t\t// VSOP arguments (k/h -> W/e)\r\n\t\t// Called pi (W) in VSOP87\r\n\t\t// k = e*cos(W) [rad]\r\n\t\t// h = e*sin(W) [rad]\r\n\t\tif ('_k' in orbit && '_h' in orbit) {\r\n\t\t\t// periapsis longitude directly from p and q\r\n\t\t\torbit._W = atan2(orbit._h, orbit._k);\r\n\t\t\t// orbit._e = orbit._k / cos(orbit._W);\r\n\t\t\torbit._e = orbit._h / sin(orbit._W);\r\n\t\t}\r\n\r\n\t\t// VSOP arguments (q/p -> O/i)\r\n\t\t// Called omega (O) in VSOP87\r\n\t\t// q = sin(i/2)*cos(O) [rad]\r\n\t\t// p = sin(i/2)*sin(O) [rad]\r\n\t\tif ('_q' in orbit && '_p' in orbit) {\r\n\t\t\t// ascending node directly from p and q\r\n\t\t\torbit._O = atan2(orbit._p, orbit._q);\r\n\t\t\t// values for inclination\r\n\t\t\tvar d = orbit._p - orbit._q,\r\n\t\t\t\t// using the faster but equivalent form for\r\n\t\t\t\t// dt = sin(orbit._O) - cos(orbit._O);\r\n\t\t\t\tdt = - sqrt(2) * sin(PI / 4 - orbit._O);\r\n\t\t\t// now calculate inclination\r\n\t\t\torbit._i = 2 * asin(d / dt);\r\n\t\t}\r\n\r\n\t\t/********************************************************/\r\n\t\t// directly related parameters for a\r\n\t\t// more stuff is calculated later on\r\n\t\t/********************************************************/\r\n\r\n\t\tif ('_n' in orbit && !('_a' in orbit)) {\r\n\t\t\t// mean motion is translated directly to size via\r\n\t\t\torbit._a = cbrt(orbit._GM / orbit._n / orbit._n);\r\n\t\t}\r\n\t\tif ('_P' in orbit && !('_a' in orbit)) {\r\n\t\t\t// period is translated directly to size via GM\r\n\t\t\tvar PTAU = orbit._P / TAU; // reuse for square\r\n\t\t\torbit._a = cbrt(orbit._GM * PTAU * PTAU);\r\n\t\t}\r\n\r\n\t\t/********************************************************/\r\n\t\t// semi-major axis and eccentricity\r\n\t\t// from apocenter and pericenter\r\n\t\t// C = a * (1 + e), c = a * (1 - e)\r\n\t\t/********************************************************/\r\n\t\tif (!('_a' in orbit)) { // semi-major axis\r\n\t\t\tif ('_c' in orbit && '_C' in orbit) { orbit._a = (orbit._C + orbit._c) / 2; }\r\n\t\t\telse if ('_e' in orbit && '_C' in orbit) { orbit._a = orbit._C / (1 + orbit._e); }\r\n\t\t\telse if ('_c' in orbit && '_e' in orbit) { orbit._a = orbit._c / (1 - orbit._e); }\r\n\t\t}\r\n\t\tif (!('_e' in orbit)) { // eccentricity\r\n\t\t\tif ('_c' in orbit && '_C' in orbit) { orbit._e = 1 - orbit._c / orbit._a; }\r\n\t\t\telse if ('_a' in orbit && '_C' in orbit) { orbit._e = orbit._C / orbit._a - 1; }\r\n\t\t\telse if ('_c' in orbit && '_a' in orbit) { orbit._e = 1 - orbit._c / orbit._a; }\r\n\t\t}\r\n\r\n\t\t/********************************************************/\r\n\t\t// orbital size parameters\r\n\t\t// a * l = b * b\r\n\t\t// l = a * (1 - e*e)\r\n\t\t// b = a * sqrt(1 - e*e)\r\n\t\t// need 2 independent arguments\r\n\t\t// there are 6 valid combination\r\n\t\t/********************************************************/\r\n\r\n\t\t// 3 valid options with e\r\n\t\tif ('_e' in orbit) {\r\n\t\t\tvar e2term = 1 - orbit._e * orbit._e;\r\n\t\t\tif ('_a' in orbit) {\r\n\t\t\t\torbit._l = orbit._a * e2term;\r\n\t\t\t\torbit._b = sqrt(orbit._a * orbit._l);\r\n\t\t\t}\r\n\t\t\telse if ('_b' in orbit) {\r\n\t\t\t\torbit._a = orbit._b / sqrt(e2term);\r\n\t\t\t\torbit._l = orbit._a * e2term;\r\n\t\t\t}\r\n\t\t\telse if ('_l' in orbit) {\r\n\t\t\t\torbit._a = orbit._l / e2term;\r\n\t\t\t\torbit._b = sqrt(orbit._a * orbit._l);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 2 valid options with a\r\n\t\telse if ('_a' in orbit) {\r\n\t\t\tif ('_b' in orbit) {\r\n\t\t\t\torbit._l = orbit._b * orbit._b / orbit._a;\r\n\t\t\t\torbit._e = sqrt(1 - orbit._l / orbit._a);\r\n\t\t\t}\r\n\t\t\telse if ('_l' in orbit) {\r\n\t\t\t\torbit._e = sqrt(1 - orbit._l / orbit._a);\r\n\t\t\t\torbit._b = sqrt(orbit._a * orbit._l);\r\n\t\t\t}\r\n\t\t}\r\n\t\t// only one valid options left\r\n\t\telse if ('_b' in orbit && '_l' in orbit) {\r\n\t\t\torbit.a = orbit._b * orbit._b / orbit._l;\r\n\t\t\torbit._e = sqrt(1 - orbit._l / orbit._a);\r\n\t\t}\r\n\r\n\t\t// calculate orbital period (P)\r\n\t\tif ('_a' in orbit && !('_P' in orbit)) {\r\n\t\t\t// calculate dependants via gravitational parameter\r\n\t\t\torbit._P = (TAU / sqrt(orbit._GM)) * pow(orbit._a, 1.5);\r\n\t\t}\r\n\t\t// calculate mean motion (n)\r\n\t\tif ('_P' in orbit && !('_n' in orbit)) {\r\n\t\t\torbit._n = TAU / orbit._P;\r\n\t\t}\r\n\t\t// specific relative angular momentum (A)\r\n\t\tif ('_P' in orbit && !('_A' in orbit)) {\r\n\t\t\tif ('_a' in orbit && '_b' in orbit) {\r\n\t\t\t\torbit._A = TAU * orbit._a * orbit._b / orbit._P;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// apsis from eccentricity and semi-major axis\r\n\t\tif ('_a' in orbit && '_e' in orbit) {\r\n\t\t\tif (!('_c' in orbit)) orbit._c = orbit._a * (1 - orbit._e);\r\n\t\t\tif (!('_C' in orbit)) orbit._C = orbit._a * (1 + orbit._e);\r\n\t\t}\r\n\r\n\t\t/********************************************************/\r\n\t\t// orientation parameters\r\n\t\t// W = L - M = O + w\r\n\t\t// need 3 independent arguments\r\n\t\t// there are 8 valid combination\r\n\t\t/********************************************************/\r\n\r\n\t\t// 5 valid options with L\r\n\t\tif ('_L' in orbit) {\r\n\t\t\tif ('_M' in orbit) {\r\n\t\t\t\t// calculate the main dependants\r\n\t\t\t\torbit._W = orbit._L - orbit._M;\r\n\t\t\t\t// calculate additional dependants\r\n\t\t\t\tif ('_O' in orbit) orbit._w = orbit._W - orbit._O;\r\n\t\t\t\telse if ('_w' in orbit) orbit._O = orbit._W - orbit._w;\r\n\t\t\t}\r\n\t\t\telse if ('_W' in orbit) {\r\n\t\t\t\t// calculate the main dependants\r\n\t\t\t\torbit._M = orbit._L - orbit._W;\r\n\t\t\t\t// calculate additional dependants\r\n\t\t\t\tif ('_O' in orbit) orbit._w = orbit._W - orbit._O;\r\n\t\t\t\telse if ('_w' in orbit) orbit._O = orbit._W - orbit._w;\r\n\t\t\t}\r\n\t\t\telse if ('_O' in orbit && '_w' in orbit) {\r\n\t\t\t\t// calculate the main dependants\r\n\t\t\t\torbit._W = orbit._O + orbit._w;\r\n\t\t\t\torbit._M = orbit._L - orbit._W;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthrow ('Orbit incomplete')\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 2 valid options with O\r\n\t\telse if ('_O' in orbit) {\r\n\t\t\tif ('_w' in orbit) {\r\n\t\t\t\t// calculate the main dependants\r\n\t\t\t\torbit._W = orbit._O + orbit._w;\r\n\t\t\t\t// calculate additional dependants\r\n\t\t\t\tif ('_M' in orbit) orbit._L = orbit._M + orbit._W;\r\n\t\t\t\t// the L case is already handled in the very first if\r\n\t\t\t\t// else if ('_L' in orbit) orbit._M = orbit._L - orbit._W;\r\n\t\t\t}\r\n\t\t\telse if ('_W' in orbit) {\r\n\t\t\t\t// calculate the main dependants\r\n\t\t\t\torbit._w = orbit._W - orbit._O;\r\n\t\t\t\t// calculate additional dependants\r\n\t\t\t\tif ('_M' in orbit) orbit._L = orbit._M + orbit._W;\r\n\t\t\t\t// the L case is already handled in the very first if\r\n\t\t\t\t// else if ('_L' in orbit) orbit._M = orbit._L - orbit._W;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthrow ('Orbit incomplete')\r\n\t\t\t}\r\n\t\t}\r\n\t\t// only one valid options left\r\n\t\telse if ('_M' in orbit && '_w' in orbit && '_W' in orbit) {\r\n\t\t\torbit._L = orbit._W + orbit._M;\r\n\t\t\torbit._O = orbit._W - orbit._w;\r\n\t\t}\r\n\r\n\t\t/********************************************************/\r\n\t\t// optionally do expensive calculations\r\n\t\t/********************************************************/\r\n\r\n\t\tif (full) orbit.m();\r\n\r\n\t\t/********************************************************/\r\n\t\t// do range corrections\r\n\t\t/********************************************************/\r\n\r\n\t\t// bring parameters into correct ranges\r\n\t\tif ('_W' in orbit) orbit._W = TURN(orbit._W); // verified\r\n\t\tif ('_L' in orbit) orbit._L = CYCLE(orbit._L); // verified\r\n\t\tif ('_M' in orbit) orbit._M = CYCLE(orbit._M); // verified\r\n\t\tif ('_O' in orbit) orbit._O = CYCLE(orbit._O); // verified\r\n\t\tif ('_w' in orbit) orbit._w = TURN(orbit._w); // verified\r\n\r\n\t\t/********************************************************/\r\n\t\t// TODO: better time epoch support\r\n\t\t/********************************************************/\r\n\t\tif ('_M' in orbit && '_n') {\r\n\t\t\torbit._T = - orbit._M / orbit._n;\r\n\t\t}\r\n\r\n\t\t// chain-able\r\n\t\treturn orbit;\r\n\r\n\t}\r\n\r\n\t/*############################################################################*/\r\n\t// Next functions are needed to calculate eccentricity anomaly and\r\n\t// related parameter (i.e. from mean anomaly to true anomaly).\r\n\t/*############################################################################*/\r\n\r\n\t/******************************************************************************/\r\n\t// In orbital mechanics, eccentric anomaly (E) is an angular parameter that\r\n\t// defines the position of a body that is moving along an elliptic Kepler\r\n\t// orbit. The eccentric anomaly (E) is one of three angular parameters\r\n\t// (\"anomalies\") that define a position along an orbit, the other two\r\n\t// being the true anomaly (m) and the mean anomaly (M).\r\n\t/******************************************************************************/\r\n\tKlass.E = function eccentricAnomaly(jy2k)\r\n\t{\r\n\r\n\t\tvar orbit = this;\r\n\t\tvar epoch = orbit._t || 0;\r\n\t\tvar dt = jy2k == null ?\r\n\t\t\t0 :  jy2k - epoch;\r\n\r\n\t\t// return cached\r\n\t\tif ('_E' in orbit && !dt) {\r\n\t\t\treturn orbit._E;\r\n\t\t}\r\n\r\n\t\t// basic parameters\r\n\t\tvar e = orbit._e, // must\r\n\t\t\tm = orbit._m, // either\r\n\t\t\tM = orbit._M; // ... or\r\n\r\n\t\t// from true anomaly (m)\r\n\t\t// much easier calculation\r\n\t\tif (!dt && e != null && m != null) {\r\n\t\t\treturn orbit._E = CYCLE(atan2(\r\n\t\t\t\tsqrt(1 - e * e) * sin(m),\r\n\t\t\t\te + cos(m)\r\n\t\t\t));\r\n\t\t}\r\n\r\n\t\t// from mean anomaly (M)\r\n\t\t// M = L - W (W = O + w)\r\n\t\t// more expensive solver loop\r\n\t\tif (e != null && M != null) {\r\n\t\t\t// advance mean anomaly for new time offset\r\n\t\t\tif (dt) M += CYCLE(orbit._n * dt);\r\n\t\t\t// NOTE: not sure why line below needs the if\r\n\t\t\t// TODO: find a unit test to exhibit edge case\r\n\t\t\t// if (!dt) M = CYCLE(orbit._n * (- orbit._T));\r\n\t\t\t// prepare for solution solver\r\n\t\t\tvar E = e < 0.8 ? M : PI;\r\n\t\t\t// var F = E - e * sin(M) - M;\r\n\t\t\t// Newton-Raphson method to solve\r\n\t\t\t// f(E) = M - E + e * sin(E) = 0\r\n\t\t\tvar f, dfdE, dE = 1;\r\n\t\t\tfor (var it = 0; abs(dE) > EPSILON && it < MAXLOOP; ++it) {\r\n\t\t\t\tf = M - E + e * sin(E);\r\n\t\t\t\tdfdE = e * cos(E) - 1.0;\r\n\t\t\t\tdE = f / dfdE;\r\n\t\t\t\tE -= dE; // next iteration\r\n\t\t\t}\r\n\t\t\t// clamp range\r\n\t\t\tE = CYCLE(E);\r\n\t\t\t// cache for zero time\r\n\t\t\tif (!dt) orbit._E = E;\r\n\t\t\t// return result\r\n\t\t\treturn E;\r\n\t\t}\r\n\r\n\t\t// remove in release version\r\n\t\tthrow ('Invalid orbital state');\r\n\r\n\t\t// fail gracefully\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/******************************************************************************/\r\n\t// In celestial mechanics, true anomaly is an angular parameter that defines the\r\n\t// position of a body moving along a Keplerian orbit. It is the angle between the\r\n\t// direction of periapsis and the current position of the body, as seen from the\r\n\t// main focus of the ellipse (the point around which the object orbits).\r\n\t/******************************************************************************/\r\n\tKlass.m = function trueAnomaly(E)\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\tif (arguments.length === 0) {\r\n\t\t\t// return cached\r\n\t\t\tif ('_m' in orbit) {\r\n\t\t\t\treturn orbit._m;\r\n\t\t\t}\r\n\t\t\t// from eccentric anomaly\r\n\t\t\t// most expensive step\r\n\t\t\tvar hE = orbit.E() / 2;\r\n\t\t\t// calculate the true anomaly\r\n\t\t\treturn orbit._m = CYCLE(2 * atan2(\r\n\t\t\t\tsqrt(1 + orbit._e) * sin(hE),\r\n\t\t\t\tsqrt(1 - orbit._e) * cos(hE)\r\n\t\t\t));\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// calculate the true anomaly\r\n\t\t\treturn CYCLE(2 * atan2(\r\n\t\t\t\tsqrt(1 + orbit._e) * sin(E / 2),\r\n\t\t\t\tsqrt(1 - orbit._e) * cos(E / 2)\r\n\t\t\t));\r\n\t\t}\r\n\t}\r\n\r\n\t/*############################################################################*/\r\n\t// additional helper functions (expensive)\r\n\t// only use them if you really need too\r\n\t// no direct way from orbital elements yet\r\n\t/*############################################################################*/\r\n\r\n\t/******************************************************************************/\r\n\t// The radial velocity of an object with respect to a given point is the rate of\r\n\t// change of the distance between the object and the point. That is, the radial\r\n\t// velocity is the component of the object's velocity that points in the direction\r\n\t// of the radius connecting the object and the point. In astronomy, the point is\r\n\t// usually taken to be the observer on Earth, so the radial velocity then denotes\r\n\t// the speed with which the object moves away from or approaches the Earth.\r\n\t/******************************************************************************/\r\n\t// Klass.vt = function tangentialVelocity() {}\r\n\t/******************************************************************************/\r\n\tKlass.B = function radialVelocity()\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\t// return cached value\r\n\t\tif ('_B' in orbit) return orbit._B;\r\n\t\t// calculate state vectors\r\n\t\tvar r = orbit.r(), v = orbit.v();\r\n\t\t// get radial velocity from state vectors\r\n\t\treturn orbit._B = r.dot(v) / r.length();\r\n\t};\r\n\r\n\t/******************************************************************************/\r\n\t// In celestial mechanics, the eccentricity vector of a Kepler orbit is the\r\n\t// dimensionless vector with direction pointing from apoapsis to periapsis and\r\n\t// with magnitude equal to the orbit's scalar eccentricity. For Kepler orbits\r\n\t// the eccentricity vector is a constant of motion. Its main use is in the\r\n\t// analysis of almost circular orbits, as perturbing (non-Keplerian) forces\r\n\t// on an actual orbit will cause the osculating eccentricity vector to change\r\n\t// continuously. For the eccentricity and argument of periapsis parameters,\r\n\t// eccentricity zero (circular orbit) corresponds to a singularity.\r\n\t/******************************************************************************/\r\n\tKlass.e3 = function eccentricity3()\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\t// return cached value\r\n\t\tif ('_e3' in orbit) return orbit._e3;\r\n\t\t// force state vector calculation\r\n\t\tvar r = orbit.r(), v = orbit.v();\r\n\t\tif (r !== null && v !== null) {\r\n\t\t\treturn orbit._e3 = r.clone().multiplyScalar(\r\n\t\t\t\tv.lengthSq() - (orbit._GM / r.length())\r\n\t\t\t).sub(\r\n\t\t\t\tv.clone().multiplyScalar(r.length() * orbit.B())\r\n\t\t\t\t).multiplyScalar(1 / orbit._GM);\r\n\t\t}\r\n\t}\r\n\r\n\t/*############################################################################*/\r\n\t// getter functions for elements that are available after resolving\r\n\t/*############################################################################*/\r\n\r\n\t// Orbit inclination is the minimum angle between a reference plane and the\r\n\t// orbital plane or axis of direction of an object in orbit around another\r\n\t// object. The inclination is one of the six orbital parameters describing\r\n\t// the shape and orientation of a celestial orbit. It is the angular distance\r\n\t// of the orbital plane from the plane of reference (usually the primary's\r\n\t// equator or the ecliptic), normally stated in degrees. In the Solar System,\r\n\t// orbital inclination is usually stated with respect to Earth's orbit.\r\n\tKlass.i = function inclination() { return this._i; }\r\n\r\n\t// The orbital eccentricity of an astronomical object is a parameter that\r\n\t// determines the amount by which its orbit around another body deviates\r\n\t// from a perfect circle. A value of 0 is a circular orbit, values between\r\n\t// 0 and 1 form an elliptical orbit, 1 is a parabolic escape orbit, and\r\n\t// greater than 1 is a hyperbola. The term derives its name from the\r\n\t// parameters of conic sections, as every Kepler orbit is a conic section.\r\n\t// It is normally used for the isolated two-body problem, but extensions\r\n\t// exist for objects following a rosette orbit through the galaxy.\r\n\tKlass.e = function eccentricity() { return this._e; }\r\n\r\n\t// In geometry, the major axis of an ellipse is its longest diameter:\r\n\t// a line segment that runs through the center and both foci, with ends\r\n\t// at the widest points of the perimeter. The semi-major axis is on half\r\n\t// of the major axis, and thus runs from the centre, through a focus, and\r\n\t// to the perimeter. Essentially, it is the radius of an orbit at the\r\n\t// orbit's two most distant points. For the special case of a circle, the\r\n\t// semi-major axis is the radius. One can think of the semi-major axis as\r\n\t// an ellipse's long radius. The length of the semi-major axis a of an\r\n\t// ellipse is related to the semi-minor axis's length b through the\r\n\t// eccentricity e and the semilatus rectum \u2113.\r\n\tKlass.a = function semiMajorAxis() { return this._a; }\r\n\tKlass.b = function semiMinorAxis() { return this._b; }\r\n\tKlass.l = function semilatusRectum() { return this._l; }\r\n\r\n\t// The point of a body's elliptical orbit about the system's centre of mass where\r\n\t// the distance between the body and the centre of mass is at its maximum.\r\n\t// For some celestial bodies, specialised terms are used (aphelion/apogee).\r\n\tKlass.C = function apocenter() { return this._C; }\r\n\t// The point of a body's elliptical orbit about the system's centre of mass where\r\n\t// the distance between the body and the centre of mass is at its minimum.\r\n\t// For some celestial bodies, specialised terms are used (perihelion/perigee).\r\n\tKlass.c = function pericenter() { return this._c; }\r\n\r\n\t// Mean longitude is the ecliptic longitude at which an orbiting body\r\n\t// could be found if its orbit were circular and free of perturbations.\r\n\t// While nominally a simple longitude, in practice the mean longitude\r\n\t// is a hybrid angle.\r\n\tKlass.L = function meanLongitude() { return this._L; }\r\n\r\n\t// The longitude of the ascending node (\u260A or \u03A9) is one of the orbital\r\n\t// elements used to specify the orbit of an object in space. It is the\r\n\t// angle from a reference direction, called the origin of longitude,\r\n\t// to the direction of the ascending node, measured in a reference plane.\r\n\t// The ascending node is the point where the orbit of the object passes\r\n\t// through the plane of reference.\r\n\tKlass.O = function ascendingNode() { return this._O; }\r\n\r\n\t// The argument of periapsis (also called argument of perifocus or\r\n\t// argument of pericenter), is one of the orbital elements (\u03C9) of\r\n\t// an orbiting body. Parametrically, \u03C9 is the angle from the body's\r\n\t// ascending node to its periapsis, measured in the direction of motion.\r\n\tKlass.w = function argOfPeriapsis() { return this._w; }\r\n\r\n\t// The time of pericenter passage when the orbiting body passes through\r\n\t// the pericenter, closest to the central body. The mean anomaly is 0.0\r\n\t// when the orbiting body is at pericenter, so defining the orbital\r\n\t// elements at the epoch T (the time of the pericenter passage)\r\n\t// eliminates the need to determine the mean anomaly.\r\n\tKlass.T = function timeOfPericenter() { return this._T; }\r\n\r\n\t// In celestial mechanics, the longitude of the periapsis (\u03D6) of\r\n\t// an orbiting body is the longitude (measured from the point of\r\n\t// the vernal equinox) at which the periapsis (closest approach\r\n\t// to the central body) would occur if the body's inclination were\r\n\t// zero. For motion of a planet around the Sun, this position could\r\n\t// be called longitude of perihelion. The longitude of periapsis is\r\n\t// a compound angle, with part of it being measured in the plane of\r\n\t// reference and the rest being measured in the plane of the orbit.\r\n\t// Likewise, any angle derived from the longitude of periapsis (e.g.\r\n\t// mean longitude and true longitude) will also be compound.\r\n\tKlass.W = function longitudeOfPeriapsis() { return this._W; }\r\n\r\n\t// In orbital mechanics, mean motion is the angular speed required\r\n\t// for a body to complete one orbit, assuming constant speed in a\r\n\t// circular orbit which completes in the same time as the variable\r\n\t// speed, elliptical orbit of the actual body.\r\n\tKlass.n = function meanMotion() { return this._n; }\r\n\r\n\t// In a closed system, no torque can be exerted on any matter\r\n\t// without the exertion on some other matter of an equal and\r\n\t// opposite torque. Hence, angular momentum can be exchanged\r\n\t// between objects in a closed system, but total angular momentum\r\n\t// before and after an exchange remains constant (is conserved)\r\n\tKlass.A = function angularMomentum() { return this._A; }\r\n\r\n\t// In celestial mechanics, the mean anomaly is an angle used in\r\n\t// calculating the position of a body in an elliptical orbit in the\r\n\t// classical two-body problem. It is the angular distance from the\r\n\t// pericenter which a fictitious body would have if it moved in a\r\n\t// circular orbit, with constant speed, in the same orbital period\r\n\t// as the actual body in its elliptical orbit. It is also the\r\n\t// product of mean motion and time since pericenter passage.\r\n\tKlass.M = function meanAnomaly() { return this._M; }\r\n\r\n\t// The orbital period is the time taken for a given object to make one\r\n\t// complete orbit around another object. When mentioned without further\r\n\t// qualification in astronomy this refers to the sidereal period of an\r\n\t// astronomical object, which is calculated with respect to the stars.\r\n\tKlass.P = function orbitalPeriod() { return this._P; }\r\n\r\n\t// In celestial mechanics, the standard gravitational parameter \u03BC of a\r\n\t// celestial body is the product of the gravitational constant G and\r\n\t// the mass M of the body. For several objects in the Solar System,\r\n\t// the value of \u03BC is known to greater accuracy than either G or M.\r\n\t// The SI units of the standard gravitational parameter are m3 s\u22122.\r\n\t// However, units of km3 s\u22122 are frequently used in the scientific\r\n\t// literature and in spacecraft navigation. AstroJS normally will\r\n\t// use units of AU3 and julian days or years (e.g. AstroJS.GMJY).\r\n\tKlass.GM = function gravitationalParameter() { return this._GM; }\r\n\r\n\t// In celestial mechanics, apsidal precession (or apsidal advance) is the\r\n\t// precession (gradual rotation) of the line connecting the apsides (line\r\n\t// of apsides) of an astronomical body's orbit. The apsides are the orbital\r\n\t// points closest (periapsis) and farthest (apoapsis) from its primary body.\r\n\t// The apsidal precession is the first time derivative of the argument of\r\n\t// periapsis, one of the six main orbital elements of an orbit. Apsidal\r\n\t// precession is considered positive when the orbit's axis rotates in the\r\n\t// same direction as the orbital motion. An apsidal period is the time\r\n\t// interval required for an orbit to precess through 360\u00B0.\r\n\tKlass.PW = function apsidalPrecession() { return this._PW; }\r\n\r\n\t// Nodal precession is the precession of the orbital plane of a satellite\r\n\t// around the rotational axis of an astronomical body such as Earth. This\r\n\t// precession is due to the non-spherical nature of a rotating body, which\r\n\t// creates a non-uniform gravitational field. The direction of precession\r\n\t// is opposite the direction of revolution. \r\n\tKlass.PO = function nodalPrecession() { return this._PO; }\r\n\r\n\t// In chronology and periodization, an epoch or reference epoch is an\r\n\t// instant in time chosen as the origin of a particular calendar era.\r\n\t// The \"epoch\" serves as a reference point from which time is measured. \r\n\tKlass.epoch = function epoch() { return this._t; }\r\n\r\n\t/*############################################################################*/\r\n\t// convert to vsop parameters (never seen them anywhere else)\r\n\t// those are calculated on demand, so you need to call me first\r\n\t/*############################################################################*/\r\n\r\n\t// q: sin(i/2)*cos(O) (vsop)\r\n\tKlass.q = function vsopPeriapsis()\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\t// return cached calculation\r\n\t\tif ('_q' in orbit) return orbit._q;\r\n\t\t// calculation given in vsop87 example.f\r\n\t\treturn orbit._q = cos(orbit._O)\r\n\t\t\t* sin(orbit._i / 2);\r\n\t};\r\n\r\n\t// p: sin(i/2)*sin(O) (vsop)\r\n\tKlass.p = function vsopApoapsis()\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\t// return cached calculation\r\n\t\tif ('_p' in orbit) return orbit._p;\r\n\t\t// calculation given in vsop87 example.f\r\n\t\treturn orbit._p = sin(orbit._O)\r\n\t\t\t* sin(orbit._i / 2);\r\n\t};\r\n\r\n\t// k: e*cos(W) (vsop)\r\n\tKlass.k = function vsopK()\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\t// return cached calculation\r\n\t\tif ('_k' in orbit) return orbit._k;\r\n\t\t// calculation given in vsop87 example.f\r\n\t\treturn orbit._k = orbit._e * cos(orbit._W);\r\n\t};\r\n\r\n\t// h: e*sin(W) (vsop)\r\n\tKlass.h = function vsopH()\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\t// return cached calculation\r\n\t\tif ('_h' in orbit) return orbit._h;\r\n\t\t// calculation given in vsop87 example.f\r\n\t\treturn orbit._h = orbit._e * sin(orbit._W);\r\n\t};\r\n\r\n\t/*############################################################################*/\r\n\t// calculate state vectors from orbital elements\r\n\t// TODO: implement for different time offsets (TBD)\r\n\t/*############################################################################*/\r\n\r\n\t// update orbital state for new epoch\r\n\t// advance position and reset some states\r\n\t// for dt = P, mean anomaly does not change\r\n\t// Note: could just get state at jy2k and\r\n\t// convert the result back to an orbit.\r\n\tKlass._update = function update(jy2k)\r\n\t{\r\n\t\tvar orbit = this;\r\n\t\tvar epoch = orbit._t || 0;\r\n\t\tvar dt = jy2k == null ?\r\n\t\t\t0 :  jy2k - epoch;\r\n\t\t// check if elements are already resolved\r\n\t\tif (!orbit.elements) orbit.resolveElements(true);\r\n\t\t// advance mean anomaly for new time\r\n\t\torbit._M = CYCLE(orbit._n * (dt - orbit._T));\r\n\t\t// adjust mean longitude for new time\r\n\t\torbit._L = CYCLE(orbit._M + orbit._W);\r\n\t\t// Argument of periapsis precession\r\n\t\tif (orbit._PW) orbit._w = dt / orbit._PW * TAU;\r\n\t\t// Longitude of the ascending node precession\r\n\t\tif (orbit._PO) orbit._O += dt / orbit._PO * TAU;\r\n\t\t// update to new epoch\r\n\t\torbit._t = dt + epoch;\r\n\t\t// reset dependent parameters\r\n\t\tdelete orbit._E; delete orbit._m;\r\n\t\t// invalidate state vectors\r\n\t\tdelete orbit._r; delete orbit._v;\r\n\t\t// chainable\r\n\t\treturn orbit;\r\n\t}\r\n\r\n\t/*\r\n\t// orbital elements to spherical position (lon/lat/r)\r\n\tKlass.sph = function spherical (jy2k)\r\n\t{\r\n\t\tvar epoch = this._t || 0;\r\n\t\tvar dt = jy2k == null ?\r\n\t\t\t0 :  jy2k - epoch;\r\n\t\t// check if elements are already resolved\r\n\t\tif (!this.elements) this.resolveElements(true);\r\n\t\tdt = dt || 0; // time offset\r\n\t}\r\n\t*/\r\n\r\n\t// orbital elements to rectangular position (x/y/z)\r\n\tKlass.state = function state(jy2k)\r\n\t{\r\n\r\n\t\tvar orbit = this, mat;\r\n\t\tvar epoch = orbit._t || 0;\r\n\t\tvar dt = jy2k == null ?\r\n\t\t\t0 :  jy2k - epoch;\r\n\r\n\t\t// check if elements are already resolved\r\n\t\tif (!orbit.elements) orbit.resolveElements(true);\r\n\r\n\t\t// return cached result for our epoch\r\n\t\t// ToDo: also cache last epoch offsets?\r\n\t\tif (!dt && '_r' in orbit && '_v' in orbit)\r\n\t\t{\r\n\t\t\t// state result\r\n\t\t\treturn {\r\n\t\t\t\tr: orbit._r,\r\n\t\t\t\tv: orbit._v,\r\n\t\t\t\tepoch: epoch,\r\n\t\t\t\torbit: orbit,\r\n\t\t\t\tGM: orbit._GM\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar e = orbit._e, a = orbit._a, i = orbit._i,\r\n\t\t\tO = orbit._O, w = orbit._w, M = orbit._M,\r\n\t\t\tE = orbit.E(jy2k), // eccentric anomaly\r\n\t\t\tm = orbit.m(E); // true anomaly\r\n\r\n\t\t// Argument of periapsis precession\r\n\t\tif (orbit._PW) w += dt / orbit._PW * TAU;\r\n\t\t// Longitude of the ascending node precession\r\n\t\tif (orbit._PO) O += dt / orbit._PO * TAU;\r\n\r\n\t\t// Distance to true anomaly position\r\n\t\tvar r = a * (1.0 - e * cos(E));\r\n\t\tvar vf = sqrt(orbit._GM * a) / r;\r\n\r\n\t\t// Perifocal reference plane\r\n\t\tvar rx = r * cos(m),\r\n\t\t\try = r * sin(m),\r\n\t\t\tvx = vf * - sin(E),\r\n\t\t\tvy = vf * sqrt(1.0 - e * e) * cos(E);\r\n\r\n\t\t// Pre-calculate elements for rotation matrix\r\n\t\tvar sinO = sin(O), cosO = cos(O),\r\n\t\t\tsinI = sin(i), cosI = cos(i),\r\n\t\t\tsinW = sin(w), cosW = cos(w),\r\n\t\t\tsinWcosO = sinW * cosO, sinWsinO = sinW * sinO,\r\n\t\t\tcosWcosO = cosW * cosO, cosWsinO = cosW * sinO,\r\n\t\t\tsinWcosI = sinW * cosI,\r\n\t\t\tFxX = cosWcosO - sinWcosI * sinO,\r\n\t\t\tFyX = cosWsinO + sinWcosI * cosO,\r\n\t\t\tFxY = cosWsinO * cosI + sinWcosO,\r\n\t\t\tFyY = cosWcosO * cosI - sinWsinO,\r\n\t\t\tFzX = sinW * sinI,\r\n\t\t\tFzY = cosW * sinI;\r\n\r\n\t\t// Equatorial position\r\n\t\tvar r = new Vector3(\r\n\t\t\trx * FxX - ry * FxY,\r\n\t\t\trx * FyX + ry * FyY,\r\n\t\t\trx * FzX + ry * FzY\r\n\t\t);\r\n\t\t// Equatorial velocity\r\n\t\tvar v = new Vector3(\r\n\t\t\tvx * FxX - vy * FxY,\r\n\t\t\tvx * FyX + vy * FyY,\r\n\t\t\tvx * FzX + vy * FzY\r\n\t\t);\r\n\t\t// cache results if no time offset\r\n\t\tif (!dt) orbit._r = r, orbit._v = v;\r\n\t\t// return result object with reference\r\n\t\t// ToDo: maybe add position object\r\n\t\t// To calculate ra/dec and more stuff\r\n\t\treturn {\r\n\t\t\tr: r,\r\n\t\t\tv: v,\r\n\t\t\tepoch: epoch,\r\n\t\t\torbit: orbit,\r\n\t\t\tGM: orbit._GM\r\n\t\t};\r\n\r\n\t}\r\n\t// EO state\r\n\r\n\t/*############################################################################*/\r\n\t// getters for state vectors\r\n\t/*############################################################################*/\r\n\r\n\t// r: position state vector\r\n\tKlass.r = function position3(jy2k)\r\n\t{\r\n\t\t// calculate at epoch time\r\n\t\t// state will cache results\r\n\t\tvar state = this.state(jy2k);\r\n\t\t// return vector\r\n\t\treturn state.r;\r\n\t}\r\n\r\n\t// v: velocity state vector\r\n\tKlass.v = function velocity3(jy2k)\r\n\t{\r\n\t\t// calculate at epoch time\r\n\t\t// state will cache results\r\n\t\tvar state = this.state(jy2k);\r\n\t\t// return vector\r\n\t\treturn state.v;\r\n\t}\r\n\r\n\t/*############################################################################*/\r\n\t// add fully named getter functions if preferred\r\n\t/*############################################################################*/\r\n\r\n\t// orbital elements that are always calculated\r\n\t// these can be used as orbital input arguments\r\n\tKlass.inclination = Klass.i;\r\n\tKlass.eccentricity = Klass.e;\r\n\tKlass.semiMajorAxis = Klass.a;\r\n\tKlass.semiMinorAxis = Klass.b;\r\n\tKlass.semilatusRectum = Klass.l;\r\n\tKlass.meanLongitude = Klass.L;\r\n\tKlass.ascendingNode = Klass.O;\r\n\tKlass.argOfPericenter = Klass.w;\r\n\tKlass.argOfPeriapsis = Klass.w;\r\n\tKlass.timeOfPericenter = Klass.T;\r\n\tKlass.longitudeOfPericenter = Klass.W;\r\n\tKlass.meanMotion = Klass.n;\r\n\tKlass.meanAnomaly = Klass.M;\r\n\tKlass.orbitalPeriod = Klass.P;\r\n\tKlass.angularMomentum = Klass.A;\r\n\tKlass.gravitationalParameter = Klass.GM;\r\n\r\n\t// first time derivates (precession periods)\r\n\tKlass.apsidalPrecession = Klass.PW;\r\n\tKlass.nodalPrecession = Klass.PO;\r\n\r\n\t// additional orbital elements only on demand\r\n\t// these must not be used as orbital input arguments\r\n\tKlass.trueAnomaly = Klass.m;\r\n\tKlass.radialVelocity = Klass.B;\r\n\tKlass.eccentricAnomaly = Klass.E;\r\n\t// additional parameters are calculated on demand\r\n\tKlass.apoapsis = Klass.C;\r\n\tKlass.aphelion = Klass.C;\r\n\tKlass.apocenter = Klass.C;\r\n\tKlass.periapsis = Klass.c;\r\n\tKlass.perhelion = Klass.c;\r\n\tKlass.pericenter = Klass.c;\r\n\r\n\t// state vectors at epoch time\r\n\tKlass.position = Klass.r;\r\n\tKlass.velocity = Klass.v;\r\n\r\n\t/*############################################################################*/\r\n\t// END OF AstroJS Orbit Module\r\n\t/*############################################################################*/\r\n\r\n\texports.Orbit = exports.Orbital = Orbit;\r\n\r\n})(this);\r\n"],
  "mappings": "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",
  "names": []
}
